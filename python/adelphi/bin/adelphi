#!python

import argparse
import logging
import os
import os.path
from functools import partial

try:
    from tempfile import TemporaryDirectory
except ImportError:
    from backports.tempfile import TemporaryDirectory

import click

from adelphi.anonymize import anonymize_keyspace
from adelphi.cql import export_cql_schema
from adelphi.gemini import export_gemini_schema, to_string
from adelphi.gh import build_github, build_repository, build_branch, commit_schemas, build_pull_request
from adelphi.store import with_cluster, build_keyspace_objects

logging.basicConfig(level=logging.INFO)
log = logging.getLogger('adelphi')

@click.group()
@click.option('--hosts', default='127.0.0.1', help='Comma-separated list of contact points. Default: 127.0.0.1')
@click.option('--port', type=int, default=9042, help='Database RPC port. Default: 9042')
@click.option('--username', help='Database username')
@click.option('--password', help='Database password')
@click.option('--keyspaces', help='Comma-separated list of keyspaces to include. If not specified, all keypaces will '
                         'be included, except system keypaces')
@click.option('--rf', type=int, help='Replication factor to override original setting. Optional.')
@click.option('--anonymize/--no-anonymize', default=True, help="Enable/disable schema anonymization")
@click.option('--output-dir', help='Directory schema files should be written to. If not specified, it will write to stdout')
@click.pass_context
def export(ctx, hosts, port, username, password, keyspaces, rf, anonymize, output_dir):

    ctx.ensure_object(dict)

    # If output-dir is specified make sure it actually exists, is a directory and is writable
    if output_dir is not None:
        if not os.path.exists(output_dir):
            log.error("Output directory " + output_dir + " does not exist")
            exit(3)
        if not os.path.isdir(output_dir):
            log.error("Specified output directory " + output_dir + " exists but is not a directory")
            exit(4)
        if not os.access(output_dir, os.W_OK):
            log.error("Output directory " + output_dir + " exists but is not writable")
            exit(5)

    ctx.obj['hosts'] = hosts.split(',')
    ctx.obj['port'] = port
    ctx.obj['username'] = username
    ctx.obj['password'] = password
    ctx.obj['keyspace_names'] = keyspaces.split(',') if keyspaces is not None else None
    ctx.obj['rf'] = rf
    ctx.obj['anonymize'] = anonymize
    ctx.obj['output-dir'] = output_dir


# Function implementing the behaviours we want to execute when provided with a metadata object
# from the driver.  This function will be used to generate a lower-arity function suitable
# for use with store.with_cluster via partial application below.
#
# Note that "cluster" must be the last non-keyword arg here in order to make the partial
# application happy
def cluster_fn(export_fn, ctx, cluster, keyspace_validation_fn = None):

    keyspace_names = ctx.obj["keyspace_names"]
    options = {'rf': ctx.obj['rf']}
    output_dir = ctx.obj["output-dir"]

    metadata = cluster.metadata
    keyspace_objects = build_keyspace_objects(keyspace_names, metadata)

    if ctx.obj['anonymize']:
        # anonymize keyspace and its children
        for keyspace_object in keyspace_objects:
            anonymize_keyspace(keyspace_object)

    log.info("Exporting schema for keyspaces %s", ','.join((k.name for k in keyspace_objects)))

    if len(keyspace_objects) == 0:
        log.info("No keyspaces selected")
        exit(1)
    if keyspace_validation_fn:
        keyspace_validation_fn(keyspace_objects)

    if output_dir is None:
        print(export_fn(keyspace_objects, options))
    else:
        for keyspace_obj in keyspace_objects:
            with open(os.path.join(output_dir, keyspace_obj.name),'w') as output_file:
                log.info("Writing schema for keyspace " + keyspace_obj.name + " to file " + output_file.name)
                output_file.write(export_fn([keyspace_obj], options))


@export.command()
@click.pass_context
def export_cql(ctx):
    my_fn = partial(cluster_fn, export_cql_schema, ctx)
    with_cluster(my_fn, **({k:ctx.obj[k] for k in ["hosts","port","username","password"]}))


@export.command()
@click.pass_context
def export_gemini(ctx):
    def my_export_fn(*args):
        return to_string(export_gemini_schema(*args))

    def validation_fn(keyspaces):
        if len(keyspaces) > 1:
            log.error("Gemini schema doesn't support multiple keyspaces.")
            exit(2)

    my_fn = partial(cluster_fn, my_export_fn, ctx)
    with_cluster(my_fn, **({k:ctx.obj[k] for k in ["hosts","port","username","password"]}))


@export.command()
@click.option('--token', help='Access token for schema storage on Github')
# TODO: Change the default to something real when we have something real
@click.option('--repo', default="absurdfarce/schema-playground", help='Name of the repo used for schema storage on Github')
@click.option('--author', help='Github username to be used for schema commits')
@click.pass_context
def github(ctx, token, repo, author):
    with TemporaryDirectory() as tmpdir:
        my_fn = partial(cluster_fn, export_cql_schema, ctx)
        ctx.obj["output-dir"] = tmpdir
        with_cluster(my_fn, **({k:ctx.obj[k] for k in ["hosts","port","username","password"]}))

        gh = build_github(token)
        repo_obj = build_repository(gh, repo)
        branch_name = build_branch(gh, repo_obj, author)
        commit_schemas(gh, repo_obj, tmpdir, branch_name, author)
        build_pull_request(repo_obj, branch_name, author)

if __name__ == '__main__':
    export(obj={}, auto_envvar_prefix="ADELPHI")
