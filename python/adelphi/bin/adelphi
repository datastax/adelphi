#!python

# Copyright DataStax, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import logging
import os
import os.path
from functools import partial

try:
    from itertools import ifilterfalse as filterfalse
except ImportError:
    from itertools import filterfalse

try:
    from tempfile import TemporaryDirectory
except ImportError:
    from backports.tempfile import TemporaryDirectory

import click

from adelphi.anonymize import anonymize_keyspace
from adelphi.cql import export_cql_schema
from adelphi.gemini import export_gemini_schema
from adelphi.gh import build_github, build_origin_repo, build_branch, commit_schemas, build_pull_request
from adelphi.store import build_keyspace_objects
from adelphi.store import with_cluster as _with_cluster

logging.basicConfig(level=logging.INFO)
log = logging.getLogger('adelphi')

# Note: click assumes a type of string and a required value of False unless explicitly specified
@click.group()
@click.option('--hosts', default='127.0.0.1', show_default=True, help='Comma-separated list of contact points')
@click.option('--port', type=int, default=9042, show_default=True, help='Database RPC port')
@click.option('--username', help='Database username')
@click.option('--password', help='Database password')
@click.option('--keyspaces',
              help='Comma-separated list of keyspaces to include. If not specified all non-system keypaces will be included')
@click.option('--rf', type=int, help='Replication factor to override original setting. Optional.')
@click.option('--anonymize/--no-anonymize', default=True, show_default=True, help="Enable/disable schema anonymization")
@click.option('--output-dir', help='Directory schema files should be written to. If not specified, it will write to stdout')
@click.option('--purpose', help='Comments on the anticipated purpose of this schema.  Optional.')
@click.option('--maturity', help='The maturity of this schema.  Sample values would include ‘alpha’, ‘beta’, ‘dev’, ‘test’ or ‘prod’.  Optional.')
@click.pass_context
def export(ctx, hosts, port, username, password, keyspaces, rf, anonymize, output_dir, purpose, maturity):

    ctx.ensure_object(dict)

    # If output-dir is specified make sure it actually exists, is a directory and is writable
    if output_dir is not None:
        if not os.path.exists(output_dir):
            log.error("Output directory " + output_dir + " does not exist")
            exit(3)
        if not os.path.isdir(output_dir):
            log.error("Specified output directory " + output_dir + " exists but is not a directory")
            exit(4)
        if not os.access(output_dir, os.W_OK):
            log.error("Output directory " + output_dir + " exists but is not writable")
            exit(5)

    ctx.obj['hosts'] = hosts.split(',')
    ctx.obj['port'] = port
    ctx.obj['username'] = username
    ctx.obj['password'] = password
    ctx.obj['keyspace_names'] = keyspaces.split(',') if keyspaces is not None else None
    ctx.obj['rf'] = rf
    ctx.obj['anonymize'] = anonymize
    ctx.obj['output-dir'] = output_dir
    ctx.obj['purpose'] = purpose
    ctx.obj['maturity'] = maturity

# ============================ Utility functions for commands ============================
# unique_everseen from itertools recipes
def unique(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --> A B C D
    # unique_everseen('ABBCcAD', str.lower) --> A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element


def with_cluster(cluster_fn, props):
    return _with_cluster(cluster_fn, **({k:props[k] for k in ["hosts","port","username","password"]}))


def get_keyspaces(props, cluster):
    keyspace_names = props["keyspace_names"]

    metadata = cluster.metadata
    keyspaces = build_keyspace_objects(keyspace_names, metadata)

    return [anonymize_keyspace(ks) for ks in keyspaces] if props['anonymize'] else keyspaces


def validate_keyspaces(keyspace_objs):
    if len(keyspace_objs) == 0:
        log.info("No keyspaces selected")
        exit(1)


def get_cluster_metadata(cluster):
    hosts = cluster.metadata.all_hosts()
    unique_dcs = unique((host.datacenter for host in hosts))
    return {"host_count": len(hosts), "dc_count": sum(1 for i in unique_dcs)}


def gather_keyspaces(props):
    partial_fn = partial(get_keyspaces, props)
    keyspaces = with_cluster(partial_fn, props)

    log.info("Processing the following keyspaces: %s", ','.join((k.name for k in keyspaces)))

    validate_keyspaces(keyspaces)
    return keyspaces


def gather_metadata(props):
    metadata = {k : props[k] for k in ["purpose", "maturity"]}
    metadata.update(with_cluster(get_cluster_metadata, props))
    return {k : metadata[k] for k in metadata.keys() if metadata[k] is not None}


def export_keyspaces(props, export_fn, keyspace_objs, metadata):
    options = {'rf': props['rf']}
    export_dir = props["output-dir"]

    if export_dir is None:
        print(export_fn(keyspace_objs, metadata, options))
    else:
        for keyspace_obj in keyspace_objs:
            with open(os.path.join(export_dir, keyspace_obj.name),'w') as output_file:
                log.info("Writing schema for keyspace " + keyspace_obj.name + " to file " + output_file.name)
                output_file.write(export_fn([keyspace_obj], metadata, options))


# ============================ Command implementations ============================
@export.command()
@click.pass_context
def export_cql(ctx):
    """Export a schema as raw CQL statements"""
    export_keyspaces(ctx.obj, export_cql_schema, gather_keyspaces(ctx.obj), gather_metadata(ctx.obj))


@export.command()
@click.pass_context
def export_gemini(ctx):
    """Export a schema in a format suitable for use with the the Gemini data integrity test framework"""
    keyspaces = gather_keyspaces(ctx.obj)

    if len(keyspaces) > 1:
        log.error("Gemini schema doesn't support multiple keyspaces.")
        exit(2)

    export_keyspaces(ctx.obj, export_gemini_schema, keyspaces, gather_metadata(ctx.obj))


@export.command()
@click.option('--token', help='Access token for schema storage on Github')
@click.pass_context
def contribute(ctx, token):
    """Contribute schemas to Adelphi"""
    if not ctx.obj["anonymize"]:
        log.error("All schemas contributed to Adelphi must be anonymized")
        exit(6)

    if ctx.obj["output-dir"]:
        log.info("Output directory is ignored when contributing a schema to Adelphi")

    with TemporaryDirectory() as tmpdir:
        props = ctx.obj.copy()
        props["output-dir"] = tmpdir
        export_keyspaces(props, export_cql_schema, gather_keyspaces(props), gather_metadata(props))

        gh = build_github(token)
        origin_repo = build_origin_repo(gh)
        fork_repo = origin_repo.create_fork()
        branch_name = build_branch(gh, fork_repo)
        commit_schemas(gh, fork_repo, tmpdir, branch_name)
        build_pull_request(gh, origin_repo, branch_name)

if __name__ == '__main__':
    export(obj={}, auto_envvar_prefix="ADELPHI")
